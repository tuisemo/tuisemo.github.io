{"meta":{"title":"慎独","subtitle":"感性是神圣的天赋，理性则像忠诚的仆人。","description":"欲语还休","author":"慎独","url":"https://tuisemo.github.io"},"pages":[{"title":"标签集","date":"2017-11-04T08:47:39.115Z","updated":"2017-11-04T08:47:39.115Z","comments":true,"path":"tags/index.html","permalink":"https://tuisemo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序构建工具wepy与redux的碰撞","slug":"小程序构建工具wepy与redux的碰撞","date":"2018-10-16T14:08:57.000Z","updated":"2018-10-16T14:12:57.387Z","comments":true,"path":"2018/10/16/小程序构建工具wepy与redux的碰撞/","link":"","permalink":"https://tuisemo.github.io/2018/10/16/小程序构建工具wepy与redux的碰撞/","excerpt":"","text":"wepy是官方推荐的微信小程序组件化开发框架，使用该框架可以类似开发vue项目的方式开发小程序，框架提供实时编译打包生成小程序原生代码的服务。 安装 1npm install wepy-cli -g 初始化项目 1wepy init standard myproject 切换至项目目录/安装依赖 123cd myprojectnpm install 开启实时编译 12345wepy build --watch// 注意：此命令开启实时编译，但属于开发模式，存在代码冗余。如果需要上线生产环境，请执行打包命令：npm run build wepy项目结构此处只列举了src目录下的文件结构 123456789101112131415161718192021222324252627282930│ app.wpy│├─components│ counter.wpy│ group.wpy│ groupitem.wpy│ list.wpy│ panel.wpy│ wepy-list.wpy│├─mixins│ test.js│├─pages│ index.wpy│└─store │ index.js │ ├─actions │ counter.js │ index.js │ ├─reducers │ counter.js │ index.js │ └─types counter.js index.js 在初始化项目的时候，我选择了使用redux，因此项目中会自动添加wepy-redux插件，并初始化一个基础的范例。wepy-redux的结构一会儿在后面会详细再介绍。 app.wpy 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;script&gt;import wepy from 'wepy'import 'wepy-async-function'import &#123; setStore &#125; from 'wepy-redux'import configStore from './store'const store = configStore()setStore(store)wepy.$store = store /*定义wepy.$store，确保组件可使用wepy.$store获取状态管理或调用相关功能*/ export default class extends wepy.app &#123; config = &#123; pages: [ 'pages/index' ], /*此处定义分包配置*/ 'subPackages': [&#123; // 分包入口A 'root': 'pages/packageA', 'pages': [ 'pages/index', 'pages/finish', 'pages/cancelPay' ] &#125;, &#123; // 分包入口B 'root': 'pages/packageB', 'pages': [ 'pages/index', 'pages/finish', 'pages/cancel', 'components/addressPick' ] &#125; ], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125; &#125; ... constructor () &#123; super() this.use('requestfix') this.use('promisify') /*添加项目对promise语法的支持*/ &#125; ...&#125;&lt;/script&gt; wepy-redux 12345678910111213│ index.js│├─actions│ counter.js│ index.js│├─reducers│ counter.js│ index.js│└─types counter.js index.js 入口文件index.js 12345678import &#123; createStore, applyMiddleware &#125; from 'redux'import promiseMiddleware from 'redux-promise' //promiseMiddleware中间件，用于action做异步处理 import rootReducer from './reducers'export default function configStore () &#123; const store = createStore(rootReducer, applyMiddleware(promiseMiddleware)) return store&#125; types types文件夹下存放文件用于定义action名称 12345678910// index.jsexport * from './counter'// counter.jsexport const INCREMENT = 'INCREMENT'export const DECREMENT = 'DECREMENT'export const ASYNC_INCREMENT = 'ASYNC_INCREMENT' reducers reducers文件夹下存放纯函数，用来更改我们的状态。 123456789101112131415161718192021222324252627282930313233343536// index.jsimport &#123; combineReducers &#125; from 'redux'import counter from './counter'export default combineReducers(&#123; counter&#125;)// counter.jsimport &#123; handleActions &#125; from 'redux-actions'import &#123; INCREMENT, DECREMENT, ASYNC_INCREMENT &#125; from '../types/counter'const defaultState = &#123; num: 0, asyncNum: 0&#125;export default handleActions(&#123; [INCREMENT] (state) &#123; return &#123; ...state, num: state.num + 1 &#125; &#125;, [DECREMENT] (state) &#123; return &#123; ...state, num: state.num - 1 &#125; &#125;, [ASYNC_INCREMENT] (state, action) &#123; return &#123; ...state, asyncNum: state.asyncNum + action.payload //此处多了个action，若在actions文件下无定义处理，则传递调用时携带的参数 &#125; &#125;&#125;, defaultState) actions 补充实现reducers下的数据异步操作 1234567891011121314151617// index.jsexport * from './counter'// counter.jsimport &#123; ASYNC_INCREMENT &#125; from '../types/counter'import &#123; createAction &#125; from 'redux-actions'export const asyncInc = createAction(ASYNC_INCREMENT, (val) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1+val) &#125;, 1000) &#125;)&#125;)/***当组件调用'asyncInc'方法时，会触发调用'ASYNC_INCREMENT'，其中携带的参数即异步函数return的值*/ 组件里如何调用wepy-redux 这里主要涉及到 connect 的用法： connect(states, actions)，这里解释下： states: 访问 state 上的值，可以是数组或者对象，如果是对象的话，则包含的是 K-V对，V 可以是函数还可以是字符串，如果是字符串的话则默认获取 state[V]， 否则的话则是使用返回值；而对于如果是数组的话（数组中的项只能为字符串），则认为是相同的 K-V 对象结构。states 最终会附加到组件的 computed 属性值上。 actions: 只能传入对象，对象的 K-V 结构，如果 V 是字符串的话，则直接会 distatch如下的结构： 1234567// args 就是调用传入参数&#123; type: val, // 修正一般情况下的参数 一般支持只传一个参数 // 如果真的是多个参数的话 那么 payload 就是参数组成的数组 payload: args.length &gt; 1 ? args : args[0]&#125; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;view class=\"counter &#123;&#123;style&#125;&#125;\"&gt; &lt;button @tap=\"plus\" size=\"mini\"&gt; + &lt;/button&gt; &lt;button @tap=\"minus\" size=\"mini\"&gt; - &lt;/button&gt; &lt;button @tap=\"incNum\" size=\"mini\"&gt; INCREMENT &lt;/button&gt; &lt;button @tap=\"decNum\" size=\"mini\"&gt; DECREMENT &lt;/button&gt; &lt;button @tap=\"test\" size=\"mini\"&gt; ASYNC INCREMENT &lt;/button&gt; &lt;text class=\"count\"&gt; &#123;&#123;num&#125;&#125; &lt;/text&gt; &lt;text class=\"count\"&gt; &#123;&#123;stateNum&#125;&#125; &lt;/text&gt; &lt;text class=\"count\"&gt; &#123;&#123;asyncNum&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import wepy from 'wepy' import &#123; connect &#125; from 'wepy-redux' import &#123; INCREMENT, DECREMENT &#125; from '../store/types/counter' import &#123; asyncInc &#125; from '../store/actions' @connect(&#123; stateNum (state) &#123; return state.counter.num &#125;, asyncNum (state) &#123; return state.counter.asyncNum &#125; &#125;, &#123; incNum: INCREMENT, decNum: DECREMENT, asyncInc // action定义的方法需要以该方式引入 &#125;) export default class Counter extends wepy.component &#123; ... methods = &#123; plus () &#123; this.num = this.num + 1 &#125;, minus () &#123; this.num = this.num - 1 &#125;, test() &#123; this.methods.asyncInc(5) //调用action里的asyncInc函数，并携带参数 wepy.$store.dispatch(&#123; type: 'ASYNC_INCREMENT', payload: 1 &#125;) // 直接调用reducers里的'ASYNC_INCREMENT'纯函数 &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuisemo.github.io/tags/vue/"}]},{"title":"Array.reduce( )实用范例","slug":"Array-reduce-实用范例","date":"2018-10-16T14:05:06.000Z","updated":"2018-10-16T14:07:30.870Z","comments":true,"path":"2018/10/16/Array-reduce-实用范例/","link":"","permalink":"https://tuisemo.github.io/2018/10/16/Array-reduce-实用范例/","excerpt":"","text":"reduce实用范例语法 arr.reduce(callback[, initialValue]) reduce为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素，接受四个参数： accumulator累计器 currentValue当前值 currentIndex当前索引 array数组 initialValue作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组，initialValue必须定义，否则会报错。 实用案例 数组去重 123456789&gt; let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];&gt; let result = arr.sort().reduce((init, current)=&gt;&#123;&gt; if(init.length===0 || init[init.length-1]!==current)&#123;&gt; init.push(current);&gt; &#125;&gt; return init;&gt; &#125;, []);&gt; console.log(result); //[1,2,3,4,5]&gt; 对象数组去重 12345678910111213141516171819202122232425&gt; var people = [&gt; &#123; name: 'Alice', age: 21 &#125;,&gt; &#123; name: 'Max', age: 20 &#125;,&gt; &#123; name: 'Jane', age: 20 &#125;,&gt; &#123; name: 'Alice', age: 21 &#125;,&gt; ];&gt; &gt; function dereplication(arr, property) &#123;&gt; // 对象数组去重&gt; const hash = &#123;&#125;;&gt; const result = arr.reduce(function(item, next) &#123;&gt; hash[next[property]] ? '' : (hash[next[property]] = true &amp;&amp; item.push(next));&gt; return item;&gt; &#125;, []);&gt; return result;&gt; &#125;&gt; &gt; var res = dereplication(people, 'name');// 将name属性作为唯一性识别标志&gt; // res is:&gt; //[&gt; // &#123; name: 'Alice', age: 21 &#125;,&gt; // &#123; name: 'Max', age: 20 &#125;,&gt; // &#123; name: 'Jane', age: 20 &#125;,&gt; //]&gt; 数组里所有值的和 12345&gt; var sum = [0, 1, 2, 3].reduce(function (a, b) &#123;&gt; return a + b;&gt; &#125;, 0);&gt; // sum is 6&gt; &gt;&gt; 累加对象数组里的值 1234567&gt; var initialValue = 0;&gt; var sum = [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce(function (accumulator, currentValue) &#123;&gt; return accumulator + currentValue.x;&gt; &#125;,initialValue)&gt; &gt; console.log(sum) // logs 6&gt; 将二维数组转化为一维 12345678&gt; var flattened = [[0, 1], [2, 3], [4, 5]].reduce(&gt; function(a, b) &#123;&gt; return a.concat(b);&gt; &#125;,&gt; []&gt; );&gt; // flattened is [0, 1, 2, 3, 4, 5]&gt; 计算数组中每个元素出现的次数 1234567891011121314&gt; var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];&gt; &gt; var countedNames = names.reduce(function (allNames, name) &#123; &gt; if (name in allNames) &#123;&gt; allNames[name]++;&gt; &#125;&gt; else &#123;&gt; allNames[name] = 1;&gt; &#125;&gt; return allNames;&gt; &#125;, &#123;&#125;);&gt; // countedNames is:&gt; // &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125;&gt; 按属性对object分类 123456789101112131415161718192021222324252627&gt; var people = [&gt; &#123; name: 'Alice', age: 21 &#125;,&gt; &#123; name: 'Max', age: 20 &#125;,&gt; &#123; name: 'Jane', age: 20 &#125;&gt; ];&gt; &gt; function groupBy(objectArray, property) &#123;&gt; return objectArray.reduce(function (acc, obj) &#123;&gt; var key = obj[property];&gt; if (!acc[key]) &#123;&gt; acc[key] = [];&gt; &#125;&gt; acc[key].push(obj);&gt; return acc;&gt; &#125;, &#123;&#125;);&gt; &#125;&gt; &gt; var groupedPeople = groupBy(people, 'age');&gt; // groupedPeople is:&gt; // &#123; &gt; // 20: [&gt; // &#123; name: 'Max', age: 20 &#125;, &gt; // &#123; name: 'Jane', age: 20 &#125;&gt; // ], &gt; // 21: [&#123; name: 'Alice', age: 21 &#125;] &gt; // &#125;&gt; 使用扩展运算符和initialValue绑定包含在对象数组中的数组 12345678910111213141516171819202122232425262728&gt; // friends - 对象数组&gt; // where object field \"books\" - list of favorite books &gt; var friends = [&#123;&gt; name: 'Anna',&gt; books: ['Bible', 'Harry Potter'],&gt; age: 21&gt; &#125;, &#123;&gt; name: 'Bob',&gt; books: ['War and peace', 'Romeo and Juliet'],&gt; age: 26&gt; &#125;, &#123;&gt; name: 'Alice',&gt; books: ['The Lord of the Rings', 'The Shining'],&gt; age: 18&gt; &#125;];&gt; &gt; // allbooks - list which will contain all friends' books + &gt; // additional list contained in initialValue&gt; var allbooks = friends.reduce(function(prev, curr) &#123;&gt; return [...prev, ...curr.books];&gt; &#125;, ['Alphabet']);&gt; &gt; // allbooks = [&gt; // 'Alphabet', 'Bible', 'Harry Potter', 'War and peace', &gt; // 'Romeo and Juliet', 'The Lord of the Rings',&gt; // 'The Shining'&gt; // ]&gt;","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"js","slug":"js","permalink":"https://tuisemo.github.io/tags/js/"}]},{"title":"数组操作大汇总","slug":"数组操作大汇总","date":"2018-10-16T13:56:59.000Z","updated":"2018-10-16T14:00:59.570Z","comments":true,"path":"2018/10/16/数组操作大汇总/","link":"","permalink":"https://tuisemo.github.io/2018/10/16/数组操作大汇总/","excerpt":"","text":"对原数组直接操作1var arr= ['Apple', 'Banana'] Array.push()——添加元素到数组的末尾 123&gt; var newArray = arr.push('Orange');&gt; //newArray: [\"Apple\", \"Banana\", \"Orange\"]&gt; Array.pop()——删除数组末尾的元素 123&gt; var newArray = arr.pop();&gt; // newArray: [\"Apple\"];&gt; Array.shift()——删除数组最前面（头部）的元素 123&gt; var newArray = arr.shift();&gt; // newArray: [\"Banana\"];&gt; Array.unshift()——添加元素到数组的头部 123&gt; var newArray = arr.unshift('Orange');&gt; // newArray: [\"Orange\",\"Apple\",\"Banana\"];&gt; Array.indexOf()——找出某个元素在数组中的索引 123&gt; var pos = Array.indexOf('Banana');&gt; // 1&gt; Array.splice(pos , n)——通过索引删除某个元素 / 从一个索引位置删除多个元素 12345678&gt; // 通过索引删除某个元素&gt; var newArray = arr.splice(1,1);&gt; // newArray: [\"Apple\"]&gt; &gt; // 从一个索引位置删除多个元素&gt; var newArray = Array.splice(0,2);&gt; // newArray: []&gt; Array.from(arrayLike , fn)——获取两个索引间的所有数值 123456&gt; var newArray = Array.from('foo');&gt; // expected output: Array [\"f\", \"o\", \"o\"]&gt; &gt; var newArray = Array.from([1, 2, 3], x =&gt; x + x);&gt; // expected output: Array [2, 4, 6]&gt; Array.of(val)——创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型 123456&gt; Array.of(7); // [7] &gt; Array.of(1, 2, 3); // [1, 2, 3]&gt; // 注意区分Array(n)&gt; Array(7); // [ , , , , , , ]&gt; Array(1, 2, 3); // [1, 2, 3]&gt; Array.isArray()——判断传入值是否数组 123456789&gt; Array.isArray([1, 2, 3]); &gt; // true&gt; Array.isArray(&#123;foo: 123&#125;); &gt; // false&gt; Array.isArray(\"foobar\"); &gt; // false&gt; Array.isArray(undefined); &gt; // false&gt; Array.reverse()——将数组中元素的位置颠倒 123&gt; var newArray = arr.reverse();&gt; // newArray: [\"Banana\", \"Apple\"]&gt; Array.sort()——对数组的元素进行排序 123&gt; var newArray = arr.sort();&gt; // newArray: [\"Apple\", \"Banana\"]&gt; 对数组操作，返回一个新的数组或期望值 Array.concat()——用于合并两个或多个数组 123456&gt; var array1 = ['a', 'b', 'c'];&gt; var array2 = ['d', 'e', 'f'];&gt; &gt; console.log(array1.concat(array2));&gt; // expected output: Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]&gt; Array.includes()——用来判断一个数组是否包含一个指定的值 1234&gt; var array1 = [1, 2, 3];&gt; array1.includes(2);&gt; // true&gt; Array.join()——将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符 1234&gt; var elements = ['Fire', 'Wind', 'Rain'];&gt; console.log(elements.join());&gt; // expected output: Fire,Wind,Rain&gt; Array.slice(pos , pos)——获取两个索引间的所有数值 12345678&gt; // 通过索引删除某个元素&gt; var newArray = arr.slice(0,1);&gt; // newArray: [\"Apple\"]&gt; &gt; // 【技巧】：拷贝一个数组&gt; var newArray = arr.slice();&gt; // newArray: [\"Apple\", \"Banana\"]&gt; 数组遍历操作 Array.forEach() 1234&gt; array.forEach(callback(currentValue, index, array)&#123;&gt; //do something&gt; &#125;, this)&gt; Array.every()——测试数组的所有元素是否都通过了指定函数的测试 1234567&gt; function isBelowThreshold(currentValue) &#123;&gt; return currentValue &lt; 40;&gt; &#125;&gt; var array1 = [1, 30, 39, 29, 10, 13];&gt; console.log(array1.every(isBelowThreshold));&gt; // expected output: true&gt; Array.some()——测试数组中的某些元素是否通过由提供的函数实现的测试 12345678&gt; var array = [1, 2, 3, 4, 5];&gt; var even = function(element) &#123;&gt; // checks whether an element is even&gt; return element % 2 === 0;&gt; &#125;;&gt; console.log(array.some(even));&gt; // expected output: true&gt; Array.filter()——创建一个新数组, 其包含通过所提供函数实现的测试的所有元素 1234567&gt; var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];&gt; &gt; const result = words.filter(word =&gt; word.length &gt; 6);&gt; &gt; console.log(result);&gt; // expected output: Array [\"exuberant\", \"destruction\", \"present\"]&gt; Array.find()——返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 12345678&gt; var array1 = [5, 12, 8, 130, 44];&gt; &gt; var found = array1.find(function(element) &#123;&gt; return element &gt; 10;&gt; &#125;);&gt; console.log(found);&gt; // expected output: 12&gt; Array.findIndex()——返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 12345678&gt; var array1 = [5, 12, 8, 130, 44];&gt; &gt; function findFirstLargeNumber(element) &#123;&gt; return element &gt; 13;&gt; &#125;&gt; console.log(array1.findIndex(findFirstLargeNumber));&gt; // expected output: 3&gt; Array.map()——创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 12345678&gt; var array1 = [1, 4, 9, 16];&gt; &gt; // pass a function to map&gt; const map1 = array1.map(x =&gt; x * 2);&gt; &gt; console.log(map1);&gt; // expected output: Array [2, 8, 18, 32]&gt; Array.reduce()——对累计器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。 1234567891011&gt; const array1 = [1, 2, 3, 4];&gt; const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;&gt; &gt; // 1 + 2 + 3 + 4&gt; console.log(array1.reduce(reducer));&gt; // expected output: 10&gt; &gt; // 5 + 1 + 2 + 3 + 4&gt; console.log(array1.reduce(reducer, 5));&gt; // expected output: 15&gt;","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"js","slug":"js","permalink":"https://tuisemo.github.io/tags/js/"}]},{"title":"新宠儿VSCode的一些实用插件","slug":"新宠儿VSCode的一些实用插件","date":"2018-10-15T13:07:29.000Z","updated":"2018-10-15T13:08:09.720Z","comments":true,"path":"2018/10/15/新宠儿VSCode的一些实用插件/","link":"","permalink":"https://tuisemo.github.io/2018/10/15/新宠儿VSCode的一些实用插件/","excerpt":"","text":"早在2016年就不时听到微软家的Visual Studio Code（下文简称VS Code），以前独自开发一个sublime就够了，后面因为公司项目原因不得已尝试了下IDEA，感觉还是太沉重了，而且还丑！今年因为参与构建公司产品涉及了前端服务，因此转用了VSCode，体验了下便爱不释手！这里分享一些比较实用的插件吧。 插件： Auto rename tag 在HTML, XML文件中修改标签时，直接在前标签名上修改，插件会自动修改后标签名。 Beautify HTML、CSS、JS、JSON语法高亮 Chinese Language Pack for Visual Studio Code 汉化中文包 CSS Peek 右键选择“ Go to Definition 和 Peek definition ”选项，可追踪至样式表中 CSS 类和 ids 定义的地方 ESLint 【重磅】 安装插件成功后重启VSCode，打开”设置”，打开“settings.json”添加以下配置内容 123456789&gt; \"eslint.validate\": [&gt; \"javascript\",&gt; \"javascriptreact\",&gt; \"html\",&gt; &#123; \"language\": \"vue\", \"autoFix\": true &#125;&gt; ],&gt; \"eslint.options\":&#123; \"plugins\": [\"html\"] &#125;,&gt; \"eslint.autoFixOnSave\": true,&gt; &gt; 通常情况下，当我们需要根据ESLint的相关错误提示手动修改并保存文件。然而VSCode提供了&quot;eslint.autoFixOnSave&quot;: true,这个配置项，当我们直接保存文件时，VSCode会自动根据项目下的.eslintrc.js文件中的相关配置对代码进行格式化修复。这个配置项在开发中很实用！ HTML Boilerplate HTML 模板扩展将不必手动写入新的 HTML 文档的 head 和 body 标签。只需在空文件中输入 html ，按 Tab 键即可生成干净的文档结构。(这一个功能貌似Emmet也提供了？) HTML CSS Support 在编写样式表的时候，自动补全功能 HTML Snippets html自动补全提示 HTML Hint html代码检测 jQuery Code Snippets juqery自动补全提示 Mithril Emmet 代码快速编写工具，装机必备，不解释。 Open in Browser Path intellisense 自动路由补全 Quokka.js Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈（我基本没用到这个插件） Vetur【重磅】 vue语法下代码补全工具，据说是综合比较下，目前VSCode上面最好的Vue插件了，配合ESLint效果无敌！ Vue VSCode Snippets 很全面的vue代码片段 VueHelper 可能是目前vscode最好的vue代码提示插件，不仅包括了vue2所有api，还含有vue-router2和vuex2的代码提示 wpy-beautify wepy脚手架下开发小程序，可使用该插件来实现代码格式优化 Monokai主题 vscode-icons 图标样式，必备插件，从此我的工作界面都比别人帅！","categories":[],"tags":[]},{"title":"巧用v-model实现组件间数据双向绑定","slug":"巧用v-model实现组件间数据双向绑定","date":"2018-10-09T13:54:09.000Z","updated":"2018-10-09T13:57:57.241Z","comments":true,"path":"2018/10/09/巧用v-model实现组件间数据双向绑定/","link":"","permalink":"https://tuisemo.github.io/2018/10/09/巧用v-model实现组件间数据双向绑定/","excerpt":"","text":"在vue的开发中，我们常常会构造自定义组件，多个自定义组件组合至父级组件中，父子组件的通信方式基本是：父组件通过Prop向子组件传递数据。 1234567891011121314151617181920212223242526&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;child :msg=\"A\"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; A:'这是一条文本数据' &#125;; &#125; ...&#125;;&lt;/script&gt;&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; prop: ['msg'], ...&#125;;&lt;/script&gt; 以上的示例中，每当父组件的变量A发生数据变动时，都会更新子组件中接收的msg。 但是，因为Prop的数据是单向流动的，父组件可以通过Prop向子组件传递数据，子组件却不能通过Prop将数据的变动再回传给父组件。 此时有一个问题，如果我们希望子组件也可以实时改变父组件的数据，那该如何处理？ 针对子父通信，vue给出了事件监听的方式，子父组件中共同定义好相应的事件名称，子组件调用内建的$emit方法并传入事件的名字，来向父级组件触发一个事件，同时$emit支持第二个参数作为数据传递。然后当在父级组件监听这个事件的时候，可以通过 $event 访问到被抛出的这个值。 以上就是官方文档给出的一个子父通信方法，具体代码详见官方文档，不是本文讲解内容。 当然了，随着vuex这样的数据管控插件的加入，组件间的通信变得更加集中化，但是比起原生的通信方式成本已增大了。 很多时候，多个组件组合使用时我们希望实现子父通信，总考虑到以下问题： 若采用官方的父子组件事件监听来实现代码较为繁琐，多个组件就要定义多个监听事件，增加代码量而且不好管控。 若引入vuex集中管理，成本较大，又感觉部分功能还达不到非使用vuex不可的程度，杀鸡焉用牛刀。 那么到底有什么最优的方法呢？ 此时我不禁想到vue的一个很特殊的指令v-model，vue文档中写道: 你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。 v-model是一个可以实现数据双向绑定的指令，那么我们可不可以使用它来实现子父通信呢？当然是可以啦！ 仔细查询文档，其实就有提到在组件上使用v-model，建议仔细阅读理解v-model机制后再继续看以下代码！ 于是我们可以尝试着修改一下之前的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;child v-model=\"A\"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; A: '这是一条文本数据' &#125;; &#125;&#125;;&lt;/script&gt;&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;input v-model=\"tempdata\"/&gt;&lt;/template&gt;&lt;script&gt;export default &#123; prop: &#123; value: &#123; type: String, default: '' &#125; &#125;, data() &#123; return &#123; tempdata: '' &#125;; &#125;, watch: &#123; value: &#123; // 若父组件的数据发生变动，及时更新，保持tempdata的值与value一致 handler(val) &#123; this.tempdata = val; &#125;, immediate: true &#125;, tempdata(val) &#123; // 当tempdata发生变动时，触发‘input’事件向父组件执行对value的修改 this.$emit('input', val); &#125;, &#125;&#125;;&lt;/script&gt; 从以上代码可以看出，主要的修改是在于子组件，针对v-model指令的特殊性，我们定义一个临时变量tempdata用于承载子组件内的数据修改，初始化时保持其值与父组件使用v-model传递来的value一致。每当tempdata发生变动时，子组件监听其变化并将该值通过$emit(&#39;input&#39;)的方式触发父组件更新value（即父组件使用v-model传递的对象变量）。 以上就是本次分享的主要内容，不难发现，其实本次的实现方式还是基于官方给出的事件监听的方式，但巧妙地使用了v-model指令为我们减少了很多代码，且更加灵活。","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuisemo.github.io/tags/vue/"}]},{"title":"Vue.js中watch的高级用法","slug":"Vue-js中watch的高级用法","date":"2018-09-19T15:20:44.000Z","updated":"2018-09-19T15:22:31.692Z","comments":true,"path":"2018/09/19/Vue-js中watch的高级用法/","link":"","permalink":"https://tuisemo.github.io/2018/09/19/Vue-js中watch的高级用法/","excerpt":"","text":"从官方文档知道，vueJS开发中视图对于数组/对象的变化捕捉需要特定的数据更新操作才会触发渲染。 那么现实开发中，我们又要如何实现对数组/对象的watch监听呢？ 普通数据的watch 1234567891011data() &#123; return &#123; tempData: 'string' &#125;;&#125;,watch: &#123; // vue监听普通数据 tempData(val) &#123; console.log(val) &#125;&#125; 对象属性的watch 1234567891011121314151617data() &#123; return &#123; params: &#123; orderType: ['1'], timeType:[] &#125; &#125;;&#125;,watch: &#123; // vue监听对象数据 params: &#123; handler(newvalue, oldvalue) &#123; console.log(&#123; 监听变化: newvalue &#125;); &#125;, deep: true &#125;&#125; 由上面的代码可以看到，二者对数据的watch监听差异在于deep这个变量，根据以上问题，可以引出Vue的一些高级用法： handler方法和immediate属性实际开发中，可以发现watch的一个特点，在Vue组件的生命周期里，最初的数据绑定阶段，watch监听并不会执行，需要等到数据发生改变时才会执行watch监听的相应计算。如果希望在初始化阶段就执行watch监听该如何处理呢？其实修改一下watch的写法就可以实现，(以之前的代码为例)代码如下： 1234567891011121314151617data() &#123; return &#123; params: &#123; orderType: ['1'], timeType:[] &#125; &#125;;&#125;,watch: &#123; // vue监听对象数据 params: &#123; handler(newvalue, oldvalue) &#123; console.log(&#123; 监听变化: newvalue &#125;); &#125;, immediate: true &#125;&#125; 上面的代码可以发现，相比原来的watch，改良后的watch多了handler和immediate，其实普通的watch方法里默认写的就是handler函数，经过vuejs的编译之后就会生成handler。 而immediate:true则表示当watch监听的变量被声明之后，会立即去执行一次handler方法。默认为immediate:false这也是之所以第一次数据赋值时并不会触发watch的原因了。 deep属性watch 里面还有一个属性 deep，默认值是 false，代表是否深度监听。受限于Vue对于对象/数组的监听限制，Vue无法检测到对象属性的添加或删除，所以监听对象的属性变化就受到限制，但是添加deep配置就可解决该问题了！","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tuisemo.github.io/tags/Vue/"}]},{"title":"JSON Server——30秒搭建一个本地的REST API服","slug":"json-server——30秒搭建一个本地的REST-API服","date":"2018-09-18T13:09:23.000Z","updated":"2018-09-18T14:36:57.522Z","comments":true,"path":"2018/09/18/json-server——30秒搭建一个本地的REST-API服/","link":"","permalink":"https://tuisemo.github.io/2018/09/18/json-server——30秒搭建一个本地的REST-API服/","excerpt":"","text":"在平时的开发过程中，前端往往都需要与服务端进行数据对接，接口联调是耗时较长的一个部分，开发中时长会发生以下情况： 前端：“这个接口帮我加一条数据” 后端：“好，稍等一会儿” 后端：“加了，你试试” … 前端：“再加一条，状态要不一样的” 后端：“emmm……你等等吧” … 很显然，这样的开发方式很费时，而且这一切还要基于服务端已经完成接口开发，而往往实际工作情况都是前后端同步开发的，所以这时候前端的“本地服务”就很重要了！ 今天要推荐的是一个自己就可以挠痒痒的神器“不求人”可快速搭建的本地模拟数据接口服务——JSON-Server JSON Server是一个基于本地json文件模拟数据库的服务，支持CORS和JSONP跨域请求，支持GET/POST/ PUT/PATCH/DELETE的请求方式。 安装 新建项目并初始化项目 npm init 生成packsge.json文件 安装json-server模块 npm install json-server -S 配置package.json 安装模块完毕后打开package.json文件，添加服务启动命令。例如： 1234567891011121314&#123; \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"json-server\": \"json-server --watch db.json\" &#125;, \"author\": \"tuisemo\", \"license\": \"ISC\", \"dependencies\": &#123; \"json-server\": \"^0.14.0\" &#125;&#125; 创建db.json 从上面的步骤可以看出来，项目里需要一个db.json文件，这个json文件就是之后我们将会使用到的“数据库”，于是我们创建一个db.json文件并在里面添加一些请求路由和响应的模拟数据。 123456789101112131415161718192021222324&#123; \"getRequset\": &#123; \"success\": true, \"msg\": \"\", \"data\": [ &#123; \"id\": 1, \"name\": \"张三\" &#125;, &#123; \"id\": 2, \"name\": \"二娃\" &#125;, &#123; \"id\": 3, \"name\": \"赵四\" &#125;, &#123; \"id\": 4, \"name\": \"老王\" &#125;] &#125;&#125; 启动 准备工作完成，执行npm run json-server 命令，运行服务可到以下结果 可以看到，json-server服务已经开启运行在3000端口，我们可使用postman测试请求一下。 至此，一个最简单的get请求模拟响应数据服务已经完成。json-server还支持其他请求类型，如post请求可以向db.json文件添加数据，相关的升级配置后续使用过程中会补充上来，感兴趣的朋友也可以直接访问该项目github地址 : https://github.com/typicode/json-server","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"工具","slug":"tools","permalink":"https://tuisemo.github.io/tags/tools/"}]},{"title":"凤梨罐头的爱情","slug":"凤梨罐头的爱情","date":"2018-07-08T12:38:00.000Z","updated":"2018-09-15T13:19:29.436Z","comments":true,"path":"2018/07/08/凤梨罐头的爱情/","link":"","permalink":"https://tuisemo.github.io/2018/07/08/凤梨罐头的爱情/","excerpt":"","text":"感情像是有保质期的凤梨罐头，过期了就过期了。但是，感情那么珍贵，往往发现过期了，你还是希望打开它再尝一口，坏没坏，能不能接收，都是看个人的。 我去看了《我不是药神》，坦白讲有个泪点一度戳中了我，当时在影院里只沉浸在剧情里，很动容，后面回家的路上又接着联想了很多。 那个场景就是 被搜出有“假药”的病人都被抓进了局子里盘问，警察逼问着让他们供出卖“假药”的人，最后一位白发苍苍的患者带着哭腔求情说道：”领导，求你一件事。求求你们别再查了。这药假不假，病人自己能不知道吗？” 是啊，药的真假在医学有严格复杂的评定标准，但对于真正的病人而言，能治病救命的药，就是实实在在的“真”。 我突然想起了关于保质期的问题，我买了很多酸奶，他们都只有25天的保质期，眼看着明天就要过期了，可是我也不可能在今天晚上把剩下的所有酸奶都喝完，我在犹豫着，是否过了今晚，在时钟的时针向12点偏转的那一刻，它们就会有一个本质的变化。我告诉自己，是不会的。 隔天的早晨，我开了杯酸奶，尝了一口，发现其实并没有想象中糟糕，让它口味变差的原因可能更多的是保质期对于我的心理作用。 保质期在告诉我，它过期了，你不能再食用它了。但我的亲自尝试告诉我，其实是可以接受的。 王家卫在《重庆森林》里拿着凤梨罐头比喻爱情，保质期一过，就该放弃了。但我想，在爱情里，多数人还是不做不到像金城武那样帅气洒脱，即便感情像是有保质期的凤梨罐头，过期了就过期了。但是，感情那么珍贵，往往发现过期了，你还是希望打开它再尝一口，坏没坏，能不能接收，都是看个人的。 以前我有瓶凤梨罐头保质期在6月1日，永久过期了。","categories":[{"name":"闲谈","slug":"chat","permalink":"https://tuisemo.github.io/categories/chat/"}],"tags":[]},{"title":"信","slug":"信","date":"2018-05-29T10:54:54.000Z","updated":"2018-09-15T13:40:52.860Z","comments":true,"path":"2018/05/29/信/","link":"","permalink":"https://tuisemo.github.io/2018/05/29/信/","excerpt":"","text":"一个月后，我收到一个从重庆寄过来的纸箱，寄件人是陈默。箱子里放着几本他最爱的书，他戴了很多年的手串，打印装订成册的《恋爱的犀牛》剧本，还有一本他的随手日记，这是我第一次有机会如此全面地窥视他的过去，仿佛他过去的每个时刻都被细心收藏，妥善安放在这本手记里。我拿起记事本，从里面掉出一张写好地址却未寄出的明信片，收件人是他自己。 其实我明白，爱情是需要物质的，有物质基础的爱情才会让人有回忆的寄托。那些讲个故事给你，写封情书给你的爱情，总是比不上开车带你自驾游，买对机票拉你说走就走。后者是会有载体的爱情。有时候不是人们不浪漫，反而是太浪漫了，我搂着你看最爱的电影情节，给你讲每个感人的画面，我牵着你在沙滩上跑来跑去，海风吹着头发，脚底踩着浪花，星空下在你耳边缓缓说着情话，望着天上一眨一眨。但海浪会退下去，天总会慢慢亮起来，清晨电话那头的你就说不爱了，你说海风好大，衣服总不够暖，浪花太冷，赤脚好疼，你总离我太远，我肚子好饿，想找个可以喂饱我的人。","categories":[{"name":"闲谈","slug":"chat","permalink":"https://tuisemo.github.io/categories/chat/"}],"tags":[]},{"title":"MongoDB安装","slug":"MongoDB安装","date":"2017-09-27T12:35:57.000Z","updated":"2017-11-04T08:47:39.084Z","comments":true,"path":"2017/09/27/MongoDB安装/","link":"","permalink":"https://tuisemo.github.io/2017/09/27/MongoDB安装/","excerpt":"","text":"下载MongoDB废话不多说，上地址点这里。 安装MongoDB双击打开安装包，一路next，知道选择安装方式时，建议可以选择“Custom”模式自定义,系统默认安装路径是C:\\Program Files\\MongoDB\\Server\\3.4\\，这里个人习惯就更改为D:\\Program Files\\MongoDB\\Server\\3.4\\了，继续next，直至完成。这里有另一个建议，就是直接在根目录下安装，即：D\\MongoDB\\，这个一会儿下面会提到 创建数据存放目录MongoDB将数据目录存储在 db 目录下。但是这个数据目录不会主动创建，我们在安装完成后需要创建它。请注意，数据目录应该放在根目录下（(如： C:\\ 或者 D:\\ 等 )。上面的说明摘抄于菜鸟教程,在网上找了很久，一直不明白为什么强调要将数据存储目录创建在根目录下，或许是考虑要提高数据交互效率？较少路径索引所消耗的时间？ 鉴于刚才我已经把MongoDB安装在D:\\Program Files\\MongoDB\\Server\\3.4\\路径下，所以我创建的数据目录为D:\\Program Files\\MongoDB\\Server\\3.4\\data\\db，同时，我还创建了一个日志目录，并新建了个空文件MongoDB.log，用于存放软件运行中的日志文件D:\\Program Files\\MongoDB\\Server\\3.4\\data\\log\\MongoDB.log 运行MongoDB在安装目录的bin\\目录（D:\\Program Files\\MongoDB\\Server\\3.4\\bin\\）中打开命令工具,运行以下代码：mongod --dbpath D:\\Program Files\\MongoDB\\Server\\3.4\\data\\dbdbpath后面的存储路径以你的实际安装路径为准 命令行出现相应的信息，即正常运行。 将MongoDB作为Windows服务运行 参数 描述 –bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP –logpath 定MongoDB日志文件，注意是指定文件不是目录 –logappend 使用追加的方式写日志 –dbpath 指定数据库路径 –port 指定服务端口号，默认端口27017 –serviceName 指定服务名称 –serviceDisplayName 指定服务名称，有多个mongodb服务时执行。 –install 指定作为一个Windows服务安装。 在管理员下执行以下命令： mongod.exe --logpath &quot;D:\\Program Files\\MongoDB\\Server\\3.4\\data\\log\\MongoDB.log&quot; --logappend --dbpath &quot;D:\\Program Files\\MongoDB\\Server\\3.4\\data\\db&quot; --serviceName &quot;YourServiceName&quot; --serviceDisplayName &quot;YourServiceName&quot; --install 以上的YourServiceName是由你自定义的服务名称。 小技巧在网上也有看到有人创建了一个mongodb.conf文件，将各个配置放在这个文件中，最后执行mongod --config &quot;Your mongodb.conf address&quot;和mongod --config &quot;Your mongodb.conf address&quot; --serviceName &quot;YourServiceName&quot; --serviceDisplayName &quot;YourServiceName&quot; --install 这种方法看着更容易理解，也方便配置，对于不擅长敲命令行的小伙伴们还是挺不错的选择，不过我自己还没试过。 再次以windows服务方式运行MongoDB随便打开命令窗口： net start MongoDB MongoDB即是你刚才设置的服务名称","categories":[],"tags":[]},{"title":"sublime使用常见问题","slug":"sublime使用常见问题","date":"2017-09-19T07:51:19.000Z","updated":"2017-11-04T08:47:39.099Z","comments":true,"path":"2017/09/19/sublime使用常见问题/","link":"","permalink":"https://tuisemo.github.io/2017/09/19/sublime使用常见问题/","excerpt":"","text":"Package install 包管理安装失败sublime使用中，时常因为网络问题，导致Package install安装失败，程序提示：there are no packages for installation导致插件无法正常获取安装。解决方案如下： 打开命令提示符，输入ping sublime.wbond.net回车，此处ping通sublime.wbond.net获取网站ip地址，（访问 :sublime.wbond.net后你会发现，其实就映射到了: packagecontrol.io）上述操作后，我得到的地址是：[50.116.33.29] 修改hosts指向。在电脑中找到hosts文件，路径C:\\Windows\\System32\\drivers\\etc\\ 使用编辑器打开，在最后新增一行： 50.116.33.29 sublime.wbond.net 保存hosts文件，重启sublime即可。 关于sublime中编写Vue组件时，文档的格式化工具当我们开发vue.js的相关程序时，严格的eslint要求编码规则需完全符合才能正常运行vue工程，网上搜了一下，也没有发现合适的sublime插件专门用于格式化vue文件，后面找到一个方法： 配置HTML/CSS/JS Prettify插件正常前端开发html/js都会安装HTML/CSS/JS Prettify插件，我们仅需在原有基础上，增加一些配置，即可支持vue文件格式化。 打开sublime的tools菜单，选择HTML/CSS/JS Prettify插件，选择Plugin Options（网上给的方案是选择prettify preference，但我并未在该配置文件里找到可配置项） 打开默认配置文件，或者你可以打开用户配置，找到”global_file_rules”这一项，你会发现有html/js/css/json等格式化规则（这些规则可在prettify preference里调整），每个规则会有对应”allowed_file_extensions”，表示规则支持的文件拓展类型。 将”vue”添加进刚才的”allowed_file_extensions”,这里我在html/js均添加了对vue文件的支持，大家可以自己决定。 至此，在vue文件中执行HTML/CSS/JS Prettify也可以完成对代码的格式化了。","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"工具","slug":"tools","permalink":"https://tuisemo.github.io/tags/tools/"}]},{"title":"gulp常用插件集合","slug":"gulp常用插件集合","date":"2017-09-12T00:56:51.000Z","updated":"2017-11-04T08:47:39.099Z","comments":true,"path":"2017/09/12/gulp常用插件集合/","link":"","permalink":"https://tuisemo.github.io/2017/09/12/gulp常用插件集合/","excerpt":"","text":"gulp-jshint js语法检测var jshint = require(&apos;gulp-jshint&apos;); gulp-jshint html语法检测var htmlhint = require(&apos;gulp-htmlhint&apos;); gulp-less less编译var less = require(&apos;gulp-less&apos;); gulp-rename 文件重命名var rename = require(&apos;gulp-rename&apos;); gulp-file-include 文件、代码段插入var fileinclude = require(&apos;gulp-file-include&apos;); gulp.task(&apos;fileinclude&apos;, function() { gulp.src(&apos;./src/*.html&apos;) .pipe(fileinclude({ prefix: &apos;&lt;!--IEhack@&apos;,//标签语法前缀 suffix: &apos;--&gt;&apos;,//标签语法后缀，最终在文档完整标签为：&lt;!--IEhack@include(&apos;./include/IEhack.html&apos;)--&gt; basepath: &apos;@file&apos;,//插入文件地址 indent: true })) .pipe(gulp.dest(&apos;dist&apos;)); }); gulp-inject html中插入js/cssvar inject = require(&apos;gulp-inject&apos;); gulp.task(&apos;inject&apos;, function() { gulp.src(&apos;./src/*.html&apos;) .pipe(inject(gulp.src([&apos;./src/js/lib/require.js&apos;], { reda: false }), { starttag: &apos;&lt;!-- inject:require:{{ext}} --&gt;&apos;, relative: true }))//最终在文档展示:&lt;!-- inject:base:css --&gt; .pipe(gulp.dest(&apos;dist&apos;)); }); gulp-clean-css css压缩var cssmin = require(&apos;gulp-clean-css&apos;); gulp.task(&apos;cssmin&apos;, function() { return gulp.src(&apos;./src/css/*css&apos;) .pipe(cssmin({ compatibility: &apos;ie8&apos; //兼容至ie8模式，默认compatibility: &apos;*&apos; Internet Explorer 10+兼容模式 debug: true //启用日志打出到控制台 })) .pipe(gulp.dest(&apos;./public/css&apos;)); }) 更多详细配置可查看gulp-clean-css gulp-base64 零碎图片转base64格式图片var base64 = require(&apos;gulp-base64&apos;); gulp.task(&apos;base64&apos;, function() { return gulp.src(&apos;./src/css/*css&apos;) .pipe(base64({ baseDir: &apos;public&apos;, //当样式表中有绝对路径的图片，则baseDir将被指定为该路径的根目录（相对于gulpfile文件） extensions: [&apos;svg&apos;, &apos;png&apos;, /\\.jpg#datauri$/i], //希望转化的图片格式，支持扩展名或正则匹配 exclude: [/\\.server\\.(com|net)\\/dynamic\\//, &apos;--live.jpg&apos;], //与extensions不同，此设置项将跳过与此匹配的图片，不转化 maxImageSize: 8 * 1024, // 设置转化图片的阈值，计量单位:bytes debug: true //启用日志打出到控制台 })) .pipe(gulp.dest(&apos;./public/css&apos;)); }) gulp-imagemin 图片压缩var imagemin = require(&apos;gulp-imagemin&apos;); gulp.task(&apos;imagemin&apos;, function() { return gulp.src(&apos;./src/images/*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;./public/images&apos;)); }) gulp-changed 只操作有过修改的文件var changed = require(&apos;gulp-changed&apos;); gulp.task(&apos;imagemin &apos;, function() { return gulp.src(&apos;./src/images/*&apos;) .pipe(changed (&apos;./public/images&apos;))//与输入目录文件对比，若无差异则不再处理 .pipe(imagemin())//此处使用图片压缩工作流做例子 .pipe(gulp.dest(&apos;./public/images&apos;)); })","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://tuisemo.github.io/tags/gulp/"}]},{"title":"使用Hexo和GitHub搭建个人博客","slug":"使用Hexo和GitHub搭建个人博客","date":"2017-09-11T13:32:57.000Z","updated":"2017-11-04T08:47:39.099Z","comments":true,"path":"2017/09/11/使用Hexo和GitHub搭建个人博客/","link":"","permalink":"https://tuisemo.github.io/2017/09/11/使用Hexo和GitHub搭建个人博客/","excerpt":"","text":"基础配置创建对应仓库在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username是你的github账号名) 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。 简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 工具安装Git安装如果你已安装了Git，可直接跳过，如果没有，那么建议自学安装，这里跳过。 Git配置当安装完Git，建议配置用户信息（用户名/邮箱地址）。此后每次提交操作，均会携带这部分信息。git config --global user.name &quot;username&quot; git config --global user.email &quot;username@example.com&quot; 关联GitHub为了能够在本地使用git管理github上的项目，需要进行一些配置，这里介绍SSH的方法。 检查电脑是否已有SSH KEYSls -al ~/.ssh 若无SSH KEYS，则生成新的SSH KEYSssh-keygen -t rsa -C &quot;your_email@example.com&quot;默认回车，会生成两个文件：id_rsa/id_rsa.pub（前者为私钥，后者为公钥）。 向SSH-AGENT添加KEY确保ssh-agent可运行ssh-agent -s添加SSH KEYssh-add ~/.ssh/id_rsa 在GitHub添加SSH KEY打开生成的SSH KEY，用编辑器打开新生成的公钥id_rsa.pub（文件默认路劲C:/Users/Administrator/.ssh/id_rsa.pub），复制里面的字符串，添加到GitHub。 测试是否关联成功ssh -T git@github.com Hexo安装Hexo安装前请确保你的电脑已安装了Node.js/Gitnpm install hexo-cli -g或cnpm i hexo-cli -g (建议可使用淘宝镜像) Hexo站点构建选择一个空文件夹hexo init上一步操作需要一点时间，请耐心，完成后会自动在文件夹内建立网站所需要的所有文件。 接下来就是安装依赖了npm install或cnpm i (减少等待时间) 此时，网站基础demo已经构建完成，我们可通过以下两个指令运行该demohexo generate或简写指令hexo g 生成站点hexo server 运行服务，可在localhost:4000 查看站点。此时的站点仅是本地查看的站点，之后需部署至GitHub。","categories":[],"tags":[]},{"title":"我的前端环境基石——nodeJS","slug":"我的前端环境基石——nodeJS","date":"2017-07-27T10:07:52.000Z","updated":"2017-11-04T08:47:39.115Z","comments":true,"path":"2017/07/27/我的前端环境基石——nodeJS/","link":"","permalink":"https://tuisemo.github.io/2017/07/27/我的前端环境基石——nodeJS/","excerpt":"","text":"Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 嗯，上面这句是抄的，不重要 在前端开发工作中，很多配合工具都依赖nodejs环境，所以安装nodejs肯定是开发工作的不二选择。 nodeJs安装也比较简单，只要去nodeJs官网下载安装包（这里或推荐nodeJs中文网下载） 由于很多时候从国外的npm下载包会比较慢，没有强迫症的同学可以选择安装淘宝镜像cpnm，代码：npm install -g cnpm --registry=https://registry.npm.taobao.org以后使用cnpm命令就会自动从淘宝镜像下载相应的包了。","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[]},{"title":"工作的背包，藏着那些小而美的事物","slug":"工作的背包，藏着那些小而美的事物","date":"2017-07-26T09:12:17.000Z","updated":"2017-11-04T08:47:39.099Z","comments":true,"path":"2017/07/26/工作的背包，藏着那些小而美的事物/","link":"","permalink":"https://tuisemo.github.io/2017/07/26/工作的背包，藏着那些小而美的事物/","excerpt":"","text":"LiceCap我已经受够了和别人无休止的远程沟通，人与人之间的语言障碍会让我失去工作的动力。 LiceCap是一个小体积的录屏软件，可以通过官方网站下载，是一款屏幕录制工具，支持导出GIF动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围。 PicPickPicPick是一个全功能的屏幕截图工具,直观的图像编辑器,颜色选择器,颜色调色板,像素标尺,量角器,瞄准线和白板等等。这个软件的需求点是可以滚动截屏这样就可以完整地截取整个网页。该软件可通过PicPick官网下载。 PocketPocket的主要功能就是将你要阅读或者一时没有读完的网页标记下来，接着同步到服务器端，然后你就可以在不同的设备上阅读。如果你在电脑上网的时间不多，一些东西又来不及看完，这时Pocket这款移动客户端就能按你的需求，在PC（IE，firefox，chrome等浏览器）上标记需要阅读的内容，接着可使用手机随时进行阅读！配合谷歌插件使用更方便。","categories":[{"name":"资源","slug":"resource","permalink":"https://tuisemo.github.io/categories/resource/"}],"tags":[{"name":"工具","slug":"tools","permalink":"https://tuisemo.github.io/tags/tools/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tuisemo.github.io/tags/JavaScript/"},{"name":"编程","slug":"coding","permalink":"https://tuisemo.github.io/tags/coding/"}]},{"title":"工欲善其事必先利其器——Sublime Text","slug":"工欲善其事必先利其器——Sublime-Text","date":"2017-07-21T03:47:50.000Z","updated":"2017-11-04T08:47:39.115Z","comments":true,"path":"2017/07/21/工欲善其事必先利其器——Sublime-Text/","link":"","permalink":"https://tuisemo.github.io/2017/07/21/工欲善其事必先利其器——Sublime-Text/","excerpt":"","text":"安装(Installtion)下载应用程序可前往 Sublime Text 官方网站 (官网的下载速度较为感人，没耐心等的小伙伴可自行搜索资源)，目前最新版本为Sublime Text 3，虽然之前的许多插件都还停留在Sublime Text 2版本的支持上，个人建议升级到最新版本，毕竟后期插件也会迭代支持。官网提供各系统各版本下载，但本人只用过Windows，所以就按照个人为例。 安装目录可根据自己喜好更改，我的习惯是将应用软件统一安装在D盘，记住安装地址，一会儿配置环境会用到。 安装时，可勾选Add to explorer context menu，这样可将快捷方式加入右键菜单中，以便快速使用Sublime Text打开文件。 添加Sublime Text到环境变量使用win + r运行sysdm.cpl打开系统属性–高级–环境变量，找到系统变量 Path 点击编辑，将刚才的安装路径 D:\\Program Files\\Sublime Text 3添加到环境变量中。 (一直使用Sublime Text也没配置变量，感觉不配置这个也用的好好的，待以后发现需求吧~) 安装Package ControlPackage Control就像是nodejs里的npm，方便用户安装、管理、卸载插件，安装插件前必定先安装Package Control。具体安装方法在Package Control 官网也写得比较清楚，可以在线安装也可以下载到本地再配置关联，这里主要介绍一下在线安装的方法：在Sublime Text中按 ctrl + ` 调出控制台。将下面的代码粘贴到控制台中，回车，等待安装完成： import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 安装过程是网络环境而定，如果失败多次，建议尝试直接下载。 等待Package Control安装成功后，重启Sublime Text，使用ctrl + shift + p打开命令板，输入Package Control选择install package即可进入安装其他插件。 完成到这一步，我们基本已经可以使用Sublime Text的基础功能了，但这个编辑工具的魅力在于多样的插件，插件的合理使用才使得这个工具显得如此强大，下一步我会介绍一些平时比较常用的插件。 插件安装Package Control 官网首页一进去，就是各个插件的实时更新列表，里面根据：最新、趋势、最流行等分类展示了各种插件，使用者可以根据各自需求安装。 EmmetHTMLBeautifyAutoprefixer这个插件主要用于补全CSS样式中的各类后缀，以前写样式的时候偶尔可能会用到，不过之后改用打包构建工具之后，就不再依靠这个了。 CSS3CSScombFileDiffsHTML-CSS-JS PrettifyHTML5jQueryLESSChineseLocalizations","categories":[{"name":"前端","slug":"big-front-end","permalink":"https://tuisemo.github.io/categories/big-front-end/"}],"tags":[{"name":"工具","slug":"tools","permalink":"https://tuisemo.github.io/tags/tools/"}]},{"title":"Markdown入门","slug":"Markdown入门","date":"2017-07-10T03:14:05.000Z","updated":"2017-11-04T08:47:39.084Z","comments":true,"path":"2017/07/10/Markdown入门/","link":"","permalink":"https://tuisemo.github.io/2017/07/10/Markdown入门/","excerpt":"","text":"标题1标题2标题3标题4 this is blockquote.this is an empty line 被包含的标题2 有些词汇比较重要。需要使用明显的标记符来突出显示后面是一个更重要的标记更重要的 以下是三种不同的列表写法： 001 002 003 001 002 003 001 002 003带层级关系的无序列表： 001 0001 0002 002 0001 0002 0003 003 004 有序列表的写法： 001 002 003 这是一个带链接.这是一个带title的链接 与链接不同的是，图片写法需要在方括号前面增加！例如 好了，现在开始我们的代码吧&lt; this is a html template&gt; 创建代码区块： $.ajax({ url: &apos;https://api.douban.com/v2/movie/in_theaters&apos;, type: &apos;GET&apos;, dataType: &apos;jsonp&apos;, data: {}, success: function(data) { that.lists = []; for (var i = 0; i &lt; data.subjects.length; i++) { that.lists.push({ id: data.subjects[i].id, alt: data.subjects[i].alt, imgsrc: data.subjects[i].images.medium, title: data.subjects[i].title, year: data.subjects[i].year }); } }, erroe: function() {} }); 以上结束入门部分。","categories":[],"tags":[]},{"title":"作者自白","slug":"作者自白","date":"2017-07-07T09:38:00.000Z","updated":"2017-11-04T08:47:39.099Z","comments":true,"path":"2017/07/07/作者自白/","link":"","permalink":"https://tuisemo.github.io/2017/07/07/作者自白/","excerpt":"","text":"我听过一个故事，里面写着这样一句话，对我影响颇深“感性是神圣的天赋，理性则像忠诚的仆人，我们建立了一个荣耀仆人却遗忘了天赋的社会”","categories":[{"name":"闲谈","slug":"chat","permalink":"https://tuisemo.github.io/categories/chat/"}],"tags":[]}]}